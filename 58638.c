struct brcmf_cfg80211_info *brcmf_cfg80211_attach(struct brcmf_pub struct device bool p2pdev_forced) struct net_device * ndev = brcmf_get_ifp ( drvr , 0 ) -> ndev ; struct brcmf_cfg80211_info * cfg ; struct wiphy * wiphy ; struct cfg80211_ops * ops ; struct brcmf_cfg80211_vif * vif ; struct brcmf_if * ifp ; if ( ! ndev )  ops = kzalloc ( sizeof ( * ops ) , GFP_KERNEL ); if ( ! ops )  memcpy ( ops , & brcmf_cfg80211_ops , sizeof ( * ops ) ); ifp = netdev_priv ( ndev ); if ( brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_WOWL_GTK ) )  ops -> set_rekey_data = brcmf_cfg80211_set_rekey_data; wiphy = wiphy_new ( ops , sizeof ( struct brcmf_cfg80211_info ) ); if ( ! wiphy )  memcpy ( wiphy -> perm_addr , drvr -> mac , ETH_ALEN ); cfg = wiphy_priv ( wiphy ); cfg -> wiphy = wiphy; cfg -> ops = ops; cfg -> pub = drvr; vif = brcmf_alloc_vif ( cfg , NL80211_IFTYPE_STATION , false ); struct brcmf_cfg80211_vif *brcmf_alloc_vif(struct brcmf_cfg80211_info enum nl80211_iftype bool pm_block) struct brcmf_cfg80211_vif * vif ; bool mbss ; vif = kzalloc ( sizeof ( * vif ) , GFP_KERNEL ); if ( ! vif )  return ERR_PTR ( - ENOMEM ) ; vif -> wdev . wiphy = cfg -> wiphy; vif -> wdev . iftype = type; vif -> pm_block = pm_block; if ( type == NL80211_IFTYPE_AP )  mbss = false; vif -> mbss = mbss; return vif ; if ( IS_ERR ( vif ) )  vif -> ifp = ifp; vif -> wdev . netdev = ndev; err = wl_init_priv ( cfg ); static s32 wl_init_priv(struct brcmf_cfg80211_info *cfg) cfg -> scan_request = NULL; cfg -> pwr_save = true; cfg -> active_scan = true; cfg -> dongle_up = false; err = brcmf_init_priv_mem ( cfg ); static s32 brcmf_init_priv_mem(struct brcmf_cfg80211_info *cfg) cfg -> conf = kzalloc ( sizeof ( * cfg -> conf ) , GFP_KERNEL ); if ( ! cfg -> conf )  cfg -> extra_buf = kzalloc ( WL_EXTRA_BUF_MAX , GFP_KERNEL ); if ( ! cfg -> extra_buf )  cfg -> wowl . nd = kzalloc ( sizeof ( * cfg -> wowl . nd ) + sizeof ( u32 ) , GFP_KERNEL ); if ( ! cfg -> wowl . nd )  cfg -> wowl . nd_info = kzalloc ( sizeof ( * cfg -> wowl . nd_info ) + sizeof ( struct cfg80211_wowlan_nd_match * ) , GFP_KERNEL ); if ( ! cfg -> wowl . nd_info )  cfg -> escan_info . escan_buf = kzalloc ( BRCMF_ESCAN_BUF_SIZE , GFP_KERNEL ); if ( ! cfg -> escan_info . escan_buf )  return 0 ; return - ENOMEM ; if ( err )  return err ; return err ; if ( err )  ifp -> vif = vif; err = brcmf_fil_cmd_int_get ( ifp , BRCMF_C_GET_VERSION , & io_type ); if ( err )  err = brcmf_setup_wiphy ( wiphy , ifp ); static int brcmf_setup_wiphy(struct wiphy *wiphy, struct brcmf_if *ifp) struct brcmf_pub * drvr = ifp -> drvr ; const struct ieee80211_iface_combination * combo ; struct ieee80211_supported_band * band ; u16 max_interfaces = 0 ; __le32 bandlist [ 3 ] ; u32 n_bands ; int err , i ; wiphy -> max_scan_ssids = WL_NUM_SCAN_MAX; wiphy -> max_scan_ie_len = BRCMF_SCAN_IE_LEN_MAX; wiphy -> max_num_pmkids = BRCMF_MAXPMKID; err = brcmf_setup_ifmodes ( wiphy , ifp ); static int brcmf_setup_ifmodes(struct wiphy *wiphy, struct brcmf_if *ifp) struct ieee80211_iface_combination * combo = NULL ; struct ieee80211_iface_limit * c0_limits = NULL ; struct ieee80211_iface_limit * p2p_limits = NULL ; struct ieee80211_iface_limit * mbss_limits = NULL ; bool mbss , p2p ; int i , c , n_combos ; mbss = brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_MBSS ); p2p = brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_P2P ); n_combos = 1 + ! ! p2p + ! ! mbss; combo = kcalloc ( n_combos , sizeof ( * combo ) , GFP_KERNEL ); if ( ! combo )  c0_limits = kcalloc ( p2p ? 3 : 2 , sizeof ( * c0_limits ) , GFP_KERNEL ); if ( ! c0_limits )  if ( p2p )  p2p_limits = kcalloc ( 4 , sizeof ( * p2p_limits ) , GFP_KERNEL ); if ( ! p2p_limits )  if ( mbss )  mbss_limits = kcalloc ( 1 , sizeof ( * mbss_limits ) , GFP_KERNEL ); if ( ! mbss_limits )  return 0 ; return - ENOMEM ; if ( err )  if ( i < wiphy -> n_iface_combinations )  i ++ , combo ++ max_interfaces = max ( max_interfaces , combo -> max_interfaces ); for (i = 0; i < max_interfaces && i < i++) wiphy -> addresses = drvr -> addresses; wiphy -> n_addresses = i; wiphy -> signal_type = CFG80211_SIGNAL_TYPE_MBM; wiphy -> cipher_suites = brcmf_cipher_suites; wiphy -> n_cipher_suites = ARRAY_SIZE ( brcmf_cipher_suites ); if ( ! brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_MFP ) )  wiphy -> n_cipher_suites --; wiphy -> bss_select_support = BIT ( NL80211_BSS_SELECT_ATTR_RSSI ) | BIT ( NL80211_BSS_SELECT_ATTR_BAND_PREF ) | BIT ( NL80211_BSS_SELECT_ATTR_RSSI_ADJUST ); wiphy -> flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT | WIPHY_FLAG_OFFCHAN_TX | WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL; if ( brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_TDLS ) )  wiphy -> flags |= WIPHY_FLAG_SUPPORTS_TDLS; if ( ! ifp -> drvr -> settings -> roamoff )  wiphy -> flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM; wiphy -> mgmt_stypes = brcmf_txrx_stypes; wiphy -> max_remain_on_channel_duration = 5000; wiphy -> vendor_commands = brcmf_vendor_cmds; wiphy -> n_vendor_commands = BRCMF_VNDR_CMDS_LAST - 1; err = brcmf_fil_cmd_data_get ( ifp , BRCMF_C_GET_BANDLIST , & bandlist , sizeof ( bandlist ) ); if ( err )  n_bands = le32_to_cpu ( bandlist [ 0 ] ); for (i = 1; i <= n_bands && i < ARRAY_SIZE(bandlist); i++) if ( bandlist [ i ] == cpu_to_le32 ( WLC_BAND_2G ) )  band = kmemdup ( & __wl_band_2ghz , sizeof ( __wl_band_2ghz ) , GFP_KERNEL ); if ( ! band )  band -> channels = kmemdup ( & __wl_2ghz_channels , sizeof ( __wl_2ghz_channels ) , GFP_KERNEL ); if ( ! band -> channels )  band -> n_channels = ARRAY_SIZE ( __wl_2ghz_channels ); wiphy -> bands [ NL80211_BAND_2GHZ ] = band; if ( bandlist [ i ] == cpu_to_le32 ( WLC_BAND_5G ) )  band = kmemdup ( & __wl_band_5ghz , sizeof ( __wl_band_5ghz ) , GFP_KERNEL ); if ( ! band )  band -> channels = kmemdup ( & __wl_5ghz_channels , sizeof ( __wl_5ghz_channels ) , GFP_KERNEL ); if ( ! band -> channels )  band -> n_channels = ARRAY_SIZE ( __wl_5ghz_channels ); wiphy -> bands [ NL80211_BAND_5GHZ ] = band; err = brcmf_setup_wiphybands ( wiphy ); static int brcmf_setup_wiphybands(struct wiphy *wiphy) struct brcmf_cfg80211_info * cfg = wiphy_priv ( wiphy ) ; struct brcmf_if * ifp = netdev_priv ( cfg_to_ndev ( cfg ) ) ; u32 nmode = 0 ; u32 bw_cap [ 2 ] = { WLC_BW_20MHZ_BIT , WLC_BW_20MHZ_BIT } ; u32 rxchain ; u32 nchain ; int err ; s32 i ; struct ieee80211_supported_band * band ; err = brcmf_fil_iovar_int_get ( ifp , "nmode" , & nmode ); err = brcmf_fil_iovar_int_get ( ifp , "rxchain" , & rxchain ); if ( err )  nchain = 1; for (nchain = 0; rxchain; nchain++) rxchain = rxchain & ( rxchain - 1 ); err = brcmf_construct_chaninfo ( cfg , bw_cap ); if ( err )  wiphy = cfg_to_wiphy ( cfg ); for (i = 0; i < ARRAY_SIZE(wiphy->bands); i++) band = wiphy -> bands [ i ]; if ( band == NULL )  if ( nmode )  brcmf_update_ht_cap ( band , bw_cap , nchain ); static void brcmf_update_ht_cap(struct ieee80211_supported_band u32 bw_cap[2], u32 nchain) band -> ht_cap . ht_supported = true; if ( bw_cap [ band -> band ] & WLC_BW_40MHZ_BIT )  band -> ht_cap . cap |= IEEE80211_HT_CAP_SGI_40; band -> ht_cap . cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40; band -> ht_cap . cap |= IEEE80211_HT_CAP_SGI_20; band -> ht_cap . cap |= IEEE80211_HT_CAP_DSSSCCK40; band -> ht_cap . ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K; band -> ht_cap . ampdu_density = IEEE80211_HT_MPDU_DENSITY_16; memset ( band -> ht_cap . mcs . rx_mask , 0xff , nchain ); band -> ht_cap . mcs . tx_params = IEEE80211_HT_MCS_TX_DEFINED; 