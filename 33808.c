static int fuse_file_flock(struct file *file, int cmd, struct file_lock *fl) struct inode * inode = file_inode ( file ) ; struct fuse_conn * fc = get_fuse_conn ( inode ) ; int err ; if ( fc -> no_flock )  err = fuse_setlk ( file , fl , 1 ); static int fuse_setlk(struct file *file, struct file_lock *fl, int flock) struct fuse_lk_in inarg ; int opcode = ( fl -> fl_flags & FL_SLEEP ) ? FUSE_SETLKW : FUSE_SETLK ; pid_t pid = fl -> fl_type != F_UNLCK ? current -> tgid : 0 ; if ( fl -> fl_lmops && fl -> fl_lmops -> lm_grant )  if ( fl -> fl_flags & FL_CLOSE )  fuse_lk_fill ( & args , file , fl , opcode , pid , flock , & inarg ); static void fuse_lk_fill(struct fuse_args *args, struct file const struct file_lock *fl, int opcode, pid_t int flock, struct fuse_lk_in *inarg) memset ( inarg , 0 , sizeof ( * inarg ) ); inarg -> fh = ff -> fh; inarg -> owner = fuse_lock_owner_id ( fc , fl -> fl_owner ); u64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id) u32 * k = fc -> scramble_key ; u64 v = ( unsigned long ) id ; u32 v0 = v ; u32 v1 = v >> 32 ; v0 += ( ( v1 << 4 ^ v1 >> 5 ) + v1 ) ^ ( sum + k [ sum & 3 ] ); v1 += ( ( v0 << 4 ^ v0 >> 5 ) + v0 ) ^ ( sum + k [ sum >> 11 & 3 ] ); return ( u64 ) v0 + ( ( u64 ) v1 << 32 ) ; inarg -> lk . start = fl -> fl_start; inarg -> lk . end = fl -> fl_end; inarg -> lk . type = fl -> fl_type; inarg -> lk . pid = pid; inarg -> lk_flags |= FUSE_LK_FLOCK; args -> in . args [ 0 ] . size = sizeof ( * inarg ); args -> in . args [ 0 ] . value = inarg; 