static int arcmsr_queue_command_lck(struct scsi_cmnd void (* done)(struct scsi_cmnd *)) struct Scsi_Host * host = cmd -> device -> host ; struct AdapterControlBlock * acb = ( struct AdapterControlBlock * ) host -> hostdata ; int target = cmd -> device -> id ; uint8_t scsicmd = cmd -> cmnd [ 0 ] ; if ( ( scsicmd == SYNCHRONIZE_CACHE ) || ( scsicmd == SEND_DIAGNOSTIC ) )  if ( target == 16 )  arcmsr_handle_virtual_command ( acb , cmd ); static void arcmsr_handle_virtual_command(struct AdapterControlBlock struct scsi_cmnd *cmd) switch ( cmd -> cmnd [ 0 ] )  if ( arcmsr_iop_message_xfer ( acb , cmd ) )  static int arcmsr_iop_message_xfer(struct AdapterControlBlock struct scsi_cmnd *cmd) char * buffer ; unsigned short use_sg ; int retvalue = 0 , transfer_len = 0 ; struct CMD_MESSAGE_FIELD * pcmdmessagefld ; uint32_t controlcode = ( uint32_t ) cmd -> cmnd [ 5 ] << 24 | ( uint32_t ) cmd -> cmnd [ 6 ] << 16 | ( uint32_t ) cmd -> cmnd [ 7 ] << 8 | ( uint32_t ) cmd -> cmnd [ 8 ] ; struct scatterlist * sg ; use_sg = scsi_sg_count ( cmd ); sg = scsi_sglist ( cmd ); buffer = kmap_atomic ( sg_page ( sg ) ) + sg -> offset; if ( use_sg > 1 )  transfer_len += sg -> length; if ( transfer_len > sizeof ( struct CMD_MESSAGE_FIELD ) )  pcmdmessagefld = ( struct CMD_MESSAGE_FIELD * ) buffer; switch ( controlcode )  unsigned char * ver_addr ; uint32_t allxfer_len = 0 ; ver_addr = kmalloc ( ARCMSR_API_DATA_BUFLEN , GFP_ATOMIC ); if ( ! ver_addr )  if ( acb -> rqbuf_getIndex != acb -> rqbuf_putIndex )  unsigned int tail = acb -> rqbuf_getIndex ; unsigned int head = acb -> rqbuf_putIndex ; allxfer_len = CIRC_CNT ( head , tail , ARCMSR_MAX_QBUFFER ); if ( allxfer_len > ARCMSR_API_DATA_BUFLEN )  allxfer_len = ARCMSR_API_DATA_BUFLEN; memcpy ( pcmdmessagefld -> messagedatabuffer , ver_addr , allxfer_len ); pcmdmessagefld -> cmdmessage . Length = allxfer_len; pcmdmessagefld -> cmdmessage . ReturnCode = ARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON; pcmdmessagefld -> cmdmessage . ReturnCode = ARCMSR_MESSAGE_RETURNCODE_OK; user_len = pcmdmessagefld -> cmdmessage . Length; memcpy ( ptmpuserbuffer , pcmdmessagefld -> messagedatabuffer , user_len ); if ( user_len > cnt2end )  memcpy ( pQbuffer , ptmpuserbuffer , cnt2end ); ptmpuserbuffer += cnt2end; user_len -= cnt2end; memcpy ( pQbuffer , ptmpuserbuffer , user_len ); acb -> wqbuf_putIndex += user_len; acb -> wqbuf_putIndex %= ARCMSR_MAX_QBUFFER; if ( acb -> acb_flags & ACB_F_MESSAGE_WQBUFFER_CLEARED )  acb -> acb_flags &= ~ACB_F_MESSAGE_WQBUFFER_CLEARED; arcmsr_write_ioctldata2iop ( acb );  arcmsr_write_ioctldata2iop(struct AdapterControlBlock *acb) if ( acb -> adapter_type & ( ACB_ADAPTER_TYPE_C | ACB_ADAPTER_TYPE_D ) )  arcmsr_write_ioctldata2iop_in_DWORD ( acb ); static void arcmsr_write_ioctldata2iop_in_DWORD(struct AdapterControlBlock *acb) if ( acb -> acb_flags & ACB_F_MESSAGE_WQBUFFER_READED )  acb -> acb_flags &= ( ~ACB_F_MESSAGE_WQBUFFER_READED ); pwbuffer = arcmsr_get_iop_wqbuffer ( acb ); static struct QBUFFER __iomem *arcmsr_get_iop_wqbuffer(struct AdapterControlBlock *acb) switch ( acb -> adapter_type )  struct MessageUnit_A __iomem * reg = acb -> pmuA ; pqbuffer = ( struct QBUFFER __iomem * ) & reg -> message_wbuffer; struct MessageUnit_B * reg = acb -> pmuB ; pqbuffer = ( struct QBUFFER __iomem * ) reg -> message_wbuffer; struct MessageUnit_C __iomem * reg = acb -> pmuC ; pqbuffer = ( struct QBUFFER __iomem * ) & reg -> message_wbuffer; struct MessageUnit_D * reg = acb -> pmuD ; pqbuffer = ( struct QBUFFER __iomem * ) reg -> message_wbuffer; return pqbuffer ; iop_data = ( uint32_t __iomem * ) pwbuffer -> data; while ( ( acb -> wqbuf_getIndex != acb -> wqbuf_putIndex ) && ( allxfer_len < 124 ) )  pQbuffer = & acb -> wqbuffer [ acb -> wqbuf_getIndex ]; * buf1 = * pQbuffer; acb -> wqbuf_getIndex ++; acb -> wqbuf_getIndex %= ARCMSR_MAX_QBUFFER; buf1 ++; writel ( data , iop_data ); iop_data ++; writel ( data , iop_data ); writel ( allxfer_len , & pwbuffer -> data_len ); kfree ( buf1 ); arcmsr_iop_message_wrote ( acb ); static void arcmsr_iop_message_wrote(struct AdapterControlBlock *acb) switch ( acb -> adapter_type )  struct MessageUnit_A __iomem * reg = acb -> pmuA ; writel ( ARCMSR_INBOUND_DRIVER_DATA_WRITE_OK , & reg -> inbound_doorbell ); struct MessageUnit_B * reg = acb -> pmuB ; writel ( ARCMSR_DRV2IOP_DATA_WRITE_OK , reg -> drv2iop_doorbell ); struct MessageUnit_C __iomem * reg = acb -> pmuC ; writel ( ARCMSR_HBCMU_DRV2IOP_DATA_WRITE_OK , & reg -> inbound_doorbell ); struct MessageUnit_D * reg = acb -> pmuD ; writel ( ARCMSR_ARC1214_DRV2IOP_DATA_IN_READY , reg -> inbound_doorbell ); if ( acb -> acb_flags & ACB_F_MESSAGE_WQBUFFER_READED )  acb -> acb_flags &= ( ~ACB_F_MESSAGE_WQBUFFER_READED ); pwbuffer = arcmsr_get_iop_wqbuffer ( acb ); static struct QBUFFER __iomem *arcmsr_get_iop_wqbuffer(struct AdapterControlBlock *acb) switch ( acb -> adapter_type )  struct MessageUnit_A __iomem * reg = acb -> pmuA ; pqbuffer = ( struct QBUFFER __iomem * ) & reg -> message_wbuffer; struct MessageUnit_B * reg = acb -> pmuB ; pqbuffer = ( struct QBUFFER __iomem * ) reg -> message_wbuffer; struct MessageUnit_C __iomem * reg = acb -> pmuC ; pqbuffer = ( struct QBUFFER __iomem * ) & reg -> message_wbuffer; struct MessageUnit_D * reg = acb -> pmuD ; pqbuffer = ( struct QBUFFER __iomem * ) reg -> message_wbuffer; return pqbuffer ; iop_data = ( uint8_t __iomem * ) pwbuffer -> data; while ( ( acb -> wqbuf_getIndex != acb -> wqbuf_putIndex ) && ( allxfer_len < 124 ) )  pQbuffer = & acb -> wqbuffer [ acb -> wqbuf_getIndex ]; writeb ( * pQbuffer , iop_data ); acb -> wqbuf_getIndex ++; acb -> wqbuf_getIndex %= ARCMSR_MAX_QBUFFER; iop_data ++; writel ( allxfer_len , & pwbuffer -> data_len ); arcmsr_iop_message_wrote ( acb ); static void arcmsr_iop_message_wrote(struct AdapterControlBlock *acb) switch ( acb -> adapter_type )  struct MessageUnit_A __iomem * reg = acb -> pmuA ; writel ( ARCMSR_INBOUND_DRIVER_DATA_WRITE_OK , & reg -> inbound_doorbell ); struct MessageUnit_B * reg = acb -> pmuB ; writel ( ARCMSR_DRV2IOP_DATA_WRITE_OK , reg -> drv2iop_doorbell ); struct MessageUnit_C __iomem * reg = acb -> pmuC ; writel ( ARCMSR_HBCMU_DRV2IOP_DATA_WRITE_OK , & reg -> inbound_doorbell ); struct MessageUnit_D * reg = acb -> pmuD ; writel ( ARCMSR_ARC1214_DRV2IOP_DATA_IN_READY , reg -> inbound_doorbell ); spin_unlock_irqrestore ( & acb -> wqbuffer_lock , flags ); if ( acb -> fw_flag == FW_DEADLOCK )  pcmdmessagefld -> cmdmessage . ReturnCode = ARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON; 