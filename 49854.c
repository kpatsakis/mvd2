static long vhost_scsi_compat_ioctl(struct file *f, unsigned int unsigned long arg) return vhost_scsi_ioctl ( f , ioctl , ( unsigned long ) compat_ptr ( arg ) ) ; static vhost_scsi_ioctl(struct file unsigned int unsigned long arg) struct vhost_scsi * vs = f -> private_data ; struct vhost_scsi_target backend ; void __user * argp = ( void __user * ) arg ; switch ( ioctl )  if ( copy_from_user ( & backend , argp , sizeof backend ) )  if ( backend . reserved != 0 )  return vhost_scsi_set_endpoint ( vs , & backend ) ; static vhost_scsi_set_endpoint(struct vhost_scsi struct vhost_scsi_target *t) struct se_portal_group * se_tpg ; struct tcm_vhost_tport * tv_tport ; struct tcm_vhost_tpg * tpg ; struct tcm_vhost_tpg * * vs_tpg ; int index , ret , i , len ; bool match = false ; for (index = 0; index < vs->dev.nvqs; ++index) if ( ! vhost_vq_access_ok ( & vs -> vqs [ index ] . vq ) )  len = sizeof ( vs_tpg [ 0 ] ) * VHOST_SCSI_MAX_TARGET; vs_tpg = kzalloc ( len , GFP_KERNEL ); if ( ! vs_tpg )  tv_tport = tpg -> tport; if ( ! strcmp ( tv_tport -> tport_name , t -> vhost_wwpn ) )  if ( vs -> vs_tpg && vs -> vs_tpg [ tpg -> tport_tpgt ] )  se_tpg = & tpg -> se_tpg; ret = configfs_depend_item ( se_tpg -> se_tpg_tfo -> tf_subsys , & se_tpg -> tpg_group . cg_item ); if ( ret )  match = true; if ( match )  memcpy ( vs -> vs_vhost_wwpn , t -> vhost_wwpn , sizeof ( vs -> vs_vhost_wwpn ) ); vq = & vs -> vqs [ i ] . vq; mutex_lock ( & vq -> mutex ); vq -> private_data = vs_tpg; vhost_init_used ( vq ); mutex_unlock ( & vq -> mutex ); vhost_scsi_flush ( vs ); static void vhost_scsi_flush(struct vhost_scsi *vs) tcm_vhost_init_inflight ( vs , old_inflight ); static void tcm_vhost_init_inflight(struct vhost_scsi struct vhost_scsi_inflight *old_inflight[]) vq = & vs -> vqs [ i ] . vq; mutex_lock ( & vq -> mutex ); idx = vs -> vqs [ i ] . inflight_idx; if ( old_inflight )  old_inflight [ i ] = & vs -> vqs [ i ] . inflights [ idx ]; vs -> vqs [ i ] . inflight_idx = idx ^ 1; new_inflight = & vs -> vqs [ i ] . inflights [ idx ^ 1 ]; kref_init ( & new_inflight -> kref ); init_completion ( & new_inflight -> comp ); mutex_unlock ( & vq -> mutex ); vhost_scsi_flush_vq ( vs , i ); static void vhost_scsi_flush_vq(struct vhost_scsi *vs, int index) vhost_poll_flush ( & vs -> vqs [ index ] . vq . poll ); vhost_work_flush ( & vs -> dev , & vs -> vs_completion_work ); vhost_work_flush ( & vs -> dev , & vs -> vs_event_work ); kfree ( vs -> vs_tpg ); vs -> vs_tpg = vs_tpg; mutex_unlock ( & vs -> dev . mutex ); 