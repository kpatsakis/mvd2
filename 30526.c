static void tcp_chr_read(void *opaque) CharDriverState * chr = opaque ; TCPCharDriver * s = chr -> opaque ; uint8_t buf [ 1024 ] ; int len , size ; if ( ! s -> connected || s -> max_size <= 0 )  len = sizeof ( buf ); if ( len > s -> max_size )  len = s -> max_size; size = tcp_chr_recv ( chr , ( void * ) buf , len ); static ssize_t tcp_chr_recv(CharDriverState *chr, char *buf, size_t len) TCPCharDriver * s = chr -> opaque ; struct msghdr msg = NULL , struct iovec iov [ 1 ] ; union { struct cmsghdr cmsg ; char control [ CMSG_SPACE ( sizeof ( int ) ) ] ; } msg_control ; ssize_t ret ; iov [ 0 ] . iov_base = buf; iov [ 0 ] . iov_len = len; msg . msg_iov = iov; msg . msg_iovlen = 1; msg . msg_control = & msg_control; msg . msg_controllen = sizeof ( msg_control ); ret = recvmsg ( s -> fd , & msg , 0 ); if ( ret > 0 && s -> is_unix )  unix_process_msgfd ( chr , & msg ); static void unix_process_msgfd(CharDriverState *chr, struct msghdr *msg) TCPCharDriver * s = chr -> opaque ; struct cmsghdr * cmsg ; for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) int fd ; if ( cmsg -> cmsg_len != CMSG_LEN ( sizeof ( int ) ) || cmsg -> cmsg_level != SOL_SOCKET || cmsg -> cmsg_type != SCM_RIGHTS )  fd = * ( ( int * ) CMSG_DATA ( cmsg ) ); if ( fd < 0 )  if ( s -> msgfd != - 1 )  close ( s -> msgfd ); s -> msgfd = fd; 