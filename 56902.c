static int arcmsr_probe(struct pci_dev *pdev, const struct pci_device_id *id) struct Scsi_Host * host ; struct AdapterControlBlock * acb ; int error ; error = pci_enable_device ( pdev ); if ( error )  host = scsi_host_alloc ( & arcmsr_scsi_host_template , sizeof ( struct AdapterControlBlock ) ); if ( ! host )  error = pci_set_dma_mask ( pdev , DMA_BIT_MASK ( 64 ) ); if ( error )  error = pci_set_dma_mask ( pdev , DMA_BIT_MASK ( 32 ) ); if ( error )  acb = ( struct AdapterControlBlock * ) host -> hostdata; memset ( acb , 0 , sizeof ( struct AdapterControlBlock ) ); acb -> pdev = pdev; acb -> host = host; spin_lock_init ( & acb -> eh_lock ); spin_lock_init ( & acb -> ccblist_lock ); spin_lock_init ( & acb -> postq_lock ); spin_lock_init ( & acb -> doneq_lock ); spin_lock_init ( & acb -> rqbuffer_lock ); spin_lock_init ( & acb -> wqbuffer_lock ); acb -> acb_flags |= ( ACB_F_MESSAGE_WQBUFFER_CLEARED | ACB_F_MESSAGE_RQBUFFER_CLEARED | ACB_F_MESSAGE_WQBUFFER_READED ); acb -> acb_flags &= ~ACB_F_SCSISTOPADAPTER; INIT_LIST_HEAD ( & acb -> ccb_free_list ); acb -> adapter_type = id -> driver_data; error = arcmsr_remap_pciregion ( acb ); static bool arcmsr_remap_pciregion(struct AdapterControlBlock *acb) struct pci_dev * pdev = acb -> pdev ; switch ( acb -> adapter_type )  acb -> pmuA = ioremap ( pci_resource_start ( pdev , 0 ) , pci_resource_len ( pdev , 0 ) ); if ( ! acb -> pmuA )  printk ( KERN_NOTICE "arcmsr%d: memory mapping region fail \n" , acb -> host -> host_no ) mem_base0 = ioremap ( pci_resource_start ( pdev , 0 ) , pci_resource_len ( pdev , 0 ) ); if ( ! mem_base0 )  printk ( KERN_NOTICE "arcmsr%d: memory mapping region fail \n" , acb -> host -> host_no ) mem_base1 = ioremap ( pci_resource_start ( pdev , 2 ) , pci_resource_len ( pdev , 2 ) ); if ( ! mem_base1 )  iounmap ( mem_base0 ); printk ( KERN_NOTICE "arcmsr%d: memory mapping region fail \n" , acb -> host -> host_no ) acb -> mem_base0 = mem_base0; acb -> mem_base1 = mem_base1; acb -> pmuC = ioremap_nocache ( pci_resource_start ( pdev , 1 ) , pci_resource_len ( pdev , 1 ) ); if ( ! acb -> pmuC )  printk ( KERN_NOTICE "arcmsr%d: memory mapping region fail \n" , acb -> host -> host_no ) if ( readl ( & acb -> pmuC -> outbound_doorbell ) & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE )  writel ( ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR , & acb -> pmuC -> outbound_doorbell_clear ); addr = ( unsigned long ) pci_resource_start ( pdev , 0 ); range = pci_resource_len ( pdev , 0 ); flags = pci_resource_flags ( pdev , 0 ); mem_base0 = ioremap ( addr , range ); if ( ! mem_base0 )  pr_notice ( "arcmsr%d: memory mapping region fail\n" , acb -> host -> host_no ); acb -> mem_base0 = mem_base0; if ( ! error )  error = arcmsr_alloc_io_queue ( acb ); static bool arcmsr_alloc_io_queue(struct AdapterControlBlock *acb) struct pci_dev * pdev = acb -> pdev ; switch ( acb -> adapter_type )  acb -> roundup_ccbsize = roundup ( sizeof ( struct MessageUnit_B ) , 32 ); dma_coherent = dma_zalloc_coherent ( & pdev -> dev , acb -> roundup_ccbsize , & dma_coherent_handle , GFP_KERNEL ); if ( ! dma_coherent )  pr_notice ( "arcmsr%d: DMA allocation failed\n" , acb -> host -> host_no ); acb -> dma_coherent_handle2 = dma_coherent_handle; acb -> dma_coherent2 = dma_coherent; reg = ( struct MessageUnit_B * ) dma_coherent; acb -> pmuB = reg; if ( acb -> pdev -> device == PCI_DEVICE_ID_ARECA_1203 )  reg -> drv2iop_doorbell = MEM_BASE0 ( ARCMSR_DRV2IOP_DOORBELL_1203 ); reg -> drv2iop_doorbell_mask = MEM_BASE0 ( ARCMSR_DRV2IOP_DOORBELL_MASK_1203 ); reg -> iop2drv_doorbell = MEM_BASE0 ( ARCMSR_IOP2DRV_DOORBELL_1203 ); reg -> iop2drv_doorbell_mask = MEM_BASE0 ( ARCMSR_IOP2DRV_DOORBELL_MASK_1203 ); reg -> drv2iop_doorbell = MEM_BASE0 ( ARCMSR_DRV2IOP_DOORBELL ); reg -> drv2iop_doorbell_mask = MEM_BASE0 ( ARCMSR_DRV2IOP_DOORBELL_MASK ); reg -> iop2drv_doorbell = MEM_BASE0 ( ARCMSR_IOP2DRV_DOORBELL ); reg -> iop2drv_doorbell_mask = MEM_BASE0 ( ARCMSR_IOP2DRV_DOORBELL_MASK ); reg -> message_wbuffer = MEM_BASE1 ( ARCMSR_MESSAGE_WBUFFER ); reg -> message_rbuffer = MEM_BASE1 ( ARCMSR_MESSAGE_RBUFFER ); reg -> message_rwbuffer = MEM_BASE1 ( ARCMSR_MESSAGE_RWBUFFER ); acb -> roundup_ccbsize = roundup ( sizeof ( struct MessageUnit_D ) , 32 ); dma_coherent = dma_zalloc_coherent ( & pdev -> dev , acb -> roundup_ccbsize , & dma_coherent_handle , GFP_KERNEL ); if ( ! dma_coherent )  pr_notice ( "arcmsr%d: DMA allocation failed\n" , acb -> host -> host_no ); acb -> dma_coherent_handle2 = dma_coherent_handle; acb -> dma_coherent2 = dma_coherent; reg = ( struct MessageUnit_D * ) dma_coherent; acb -> pmuD = reg; reg -> chip_id = MEM_BASE0 ( ARCMSR_ARC1214_CHIP_ID ); reg -> cpu_mem_config = MEM_BASE0 ( ARCMSR_ARC1214_CPU_MEMORY_CONFIGURATION ); reg -> i2o_host_interrupt_mask = MEM_BASE0 ( ARCMSR_ARC1214_I2_HOST_INTERRUPT_MASK ); reg -> sample_at_reset = MEM_BASE0 ( ARCMSR_ARC1214_SAMPLE_RESET ); reg -> reset_request = MEM_BASE0 ( ARCMSR_ARC1214_RESET_REQUEST ); reg -> host_int_status = MEM_BASE0 ( ARCMSR_ARC1214_MAIN_INTERRUPT_STATUS ); reg -> pcief0_int_enable = MEM_BASE0 ( ARCMSR_ARC1214_PCIE_F0_INTERRUPT_ENABLE ); reg -> inbound_msgaddr0 = MEM_BASE0 ( ARCMSR_ARC1214_INBOUND_MESSAGE0 ); reg -> inbound_msgaddr1 = MEM_BASE0 ( ARCMSR_ARC1214_INBOUND_MESSAGE1 ); reg -> outbound_msgaddr0 = MEM_BASE0 ( ARCMSR_ARC1214_OUTBOUND_MESSAGE0 ); reg -> outbound_msgaddr1 = MEM_BASE0 ( ARCMSR_ARC1214_OUTBOUND_MESSAGE1 ); reg -> inbound_doorbell = MEM_BASE0 ( ARCMSR_ARC1214_INBOUND_DOORBELL ); reg -> outbound_doorbell = MEM_BASE0 ( ARCMSR_ARC1214_OUTBOUND_DOORBELL ); reg -> outbound_doorbell_enable = MEM_BASE0 ( ARCMSR_ARC1214_OUTBOUND_DOORBELL_ENABLE ); reg -> inboundlist_base_low = MEM_BASE0 ( ARCMSR_ARC1214_INBOUND_LIST_BASE_LOW ); reg -> inboundlist_base_high = MEM_BASE0 ( ARCMSR_ARC1214_INBOUND_LIST_BASE_HIGH ); reg -> inboundlist_write_pointer = MEM_BASE0 ( ARCMSR_ARC1214_INBOUND_LIST_WRITE_POINTER ); reg -> outboundlist_base_low = MEM_BASE0 ( ARCMSR_ARC1214_OUTBOUND_LIST_BASE_LOW ); reg -> outboundlist_base_high = MEM_BASE0 ( ARCMSR_ARC1214_OUTBOUND_LIST_BASE_HIGH ); reg -> outboundlist_copy_pointer = MEM_BASE0 ( ARCMSR_ARC1214_OUTBOUND_LIST_COPY_POINTER ); reg -> outboundlist_read_pointer = MEM_BASE0 ( ARCMSR_ARC1214_OUTBOUND_LIST_READ_POINTER ); reg -> outboundlist_interrupt_cause = MEM_BASE0 ( ARCMSR_ARC1214_OUTBOUND_INTERRUPT_CAUSE ); reg -> outboundlist_interrupt_enable = MEM_BASE0 ( ARCMSR_ARC1214_OUTBOUND_INTERRUPT_ENABLE ); reg -> message_wbuffer = MEM_BASE0 ( ARCMSR_ARC1214_MESSAGE_WBUFFER ); reg -> message_rbuffer = MEM_BASE0 ( ARCMSR_ARC1214_MESSAGE_RBUFFER ); reg -> msgcode_rwbuffer = MEM_BASE0 ( ARCMSR_ARC1214_MESSAGE_RWBUFFER ); if ( ! error )  