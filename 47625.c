static sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos) int mxsize , cmd_size , k ; int input_size , blocking ; unsigned char opcode ; Sg_device * sdp ; Sg_fd * sfp ; Sg_request * srp ; struct sg_header old_hdr ; unsigned char cmnd [ SG_MAX_CDB_SIZE ] ; if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) )  if ( atomic_read ( & sdp -> detaching ) )  if ( ! ( ( filp -> f_flags & O_NONBLOCK ) || scsi_block_when_processing_errors ( sdp -> device ) ) )  if ( ! access_ok ( VERIFY_READ , buf , count ) )  if ( count < SZ_SG_HEADER )  if ( __copy_from_user ( & old_hdr , buf , SZ_SG_HEADER ) )  blocking = ! ( filp -> f_flags & O_NONBLOCK ); if ( old_hdr . reply_len < 0 )  if ( count < ( SZ_SG_HEADER + 6 ) )  if ( ! ( srp = sg_add_request ( sfp ) ) )  buf += SZ_SG_HEADER; if ( sfp -> next_cmd_len > 0 )  cmd_size = sfp -> next_cmd_len; sfp -> next_cmd_len = 0; cmd_size = COMMAND_SIZE ( opcode ); if ( ( opcode >= 0xc0 ) && old_hdr . twelve_byte )  cmd_size = 12; input_size = count - cmd_size; input_size -= SZ_SG_HEADER; if ( input_size < 0 )  if ( __copy_from_user ( cmnd , buf , cmd_size ) )  k = sg_common_write ( sfp , srp , cmnd , sfp -> timeout , blocking ); static sg_common_write(Sg_fd * sfp, Sg_request * unsigned char *cmnd, int timeout, int blocking) int k , at_head ; srp -> data . cmd_opcode = cmnd [ 0 ]; k = sg_start_req ( srp , cmnd ); if ( k )  sg_finish_rem_req ( srp ); static sg_finish_rem_req(Sg_request *srp) Sg_fd * sfp = srp -> parentfp ; Sg_scatter_hold * req_schp = & srp -> data ; if ( srp -> res_used )  sg_remove_scat ( sfp , req_schp ); static sg_remove_scat(Sg_fd * sfp, Sg_scatter_hold * schp) memset ( schp , 0 , sizeof ( * schp ) ); 