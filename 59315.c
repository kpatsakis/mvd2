static CVE_2011_1076_VULN_dns_resolver_instantiate(struct key *key, const void *_data, size_t datalen) const char * data = _data , * end , * opt ; if ( datalen <= 1 || ! data || data [ datalen - 1 ] != '\0' )  datalen --; opt = memchr ( data , '#' , datalen ); if ( ! opt )  result_len = opt - data; opt ++; kdebug ( "options: '%s'" , opt ); next_opt = memchr ( opt , '#' , end - opt ) ? : end opt_len = next_opt - opt; if ( ! opt_len )  eq = memchr ( opt , '=' , opt_len ) ? : end opt_nlen = eq - opt; eq ++; opt_vlen = next_opt - eq; tmp = opt_vlen >= 0 ? opt_vlen : 0; kdebug ( "option '%*.*s' val '%*.*s'" , opt_nlen , opt_nlen , opt , tmp , tmp , eq ); if ( opt_nlen == sizeof ( DNS_ERRORNO_OPTION ) - 1 && memcmp ( opt , DNS_ERRORNO_OPTION , opt_nlen ) == 0 )  if ( opt_vlen <= 0 )  ret = strict_strtoul ( eq , 10 , & derrno ); if ( ret < 0 )  printk ( "Option '%*.*s' to dns_resolver key " bad/missing value\n" opt_nlen , opt_nlen , opt , key -> serial ) while ( opt = next_opt + 1 , opt < end )  ret = key_payload_reserve ( key , result_len ); if ( ret < 0 )  upayload = kmalloc ( sizeof ( * upayload ) + result_len + 1 , GFP_KERNEL ); if ( ! upayload )  upayload -> datalen = result_len; memcpy ( upayload -> data , data , result_len ); upayload -> data [ result_len ] = '\0'; rcu_assign_pointer ( key -> payload . data , upayload ); 