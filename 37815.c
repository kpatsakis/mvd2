static int unix_seqpacket_recvmsg(struct socket *sock, struct msghdr size_t size, int flags) struct sock * sk = sock -> sk ; if ( sk -> sk_state != TCP_ESTABLISHED )  return unix_dgram_recvmsg ( sock , msg , size , flags ) ; static int unix_dgram_recvmsg(struct socket *sock, struct msghdr size_t size, int flags) struct scm_cookie scm ; struct sock * sk = sock -> sk ; struct unix_sock * u = unix_sk ( sk ) ; struct sk_buff * skb ; int err ; int peeked , skip ; err = - EOPNOTSUPP; if ( flags & MSG_OOB )  err = mutex_lock_interruptible ( & u -> readlock ); if ( unlikely ( err ) )  skip = sk_peek_offset ( sk , flags ); skb = __skb_recv_datagram ( sk , flags , & peeked , & skip , & err ); if ( ! skb )  if ( size > skb -> len - skip )  size = skb -> len - skip; if ( size < skb -> len - skip )  msg -> msg_flags |= MSG_TRUNC; err = skb_copy_datagram_msg ( skb , skip , msg , size ); if ( err )  memset ( & scm , 0 , sizeof ( scm ) ); scm_set_cred ( & scm , UNIXCB ( skb ) . pid , UNIXCB ( skb ) . uid , UNIXCB ( skb ) . gid ); unix_set_secdata ( & scm , skb ); static inline void unix_set_secdata(struct scm_cookie *scm, struct sk_buff *skb) scm -> secid = UNIXCB ( skb ) . secid; unix_detach_fds ( & scm , skb ); static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb) scm -> fp = UNIXCB ( skb ) . fp; UNIXCB ( skb ) . fp = NULL; for (i = scm->fp->count-1; i >= 0; i--) unix_notinflight ( scm -> fp -> fp [ i ] ); scm . fp = scm_fp_dup ( UNIXCB ( skb ) . fp ); scm_recv ( sock , msg , & scm , flags ); 