bool branchAndStartLoopBody(MDefinition* cond, MBasicBlock** afterLoop, ParseNode* bodyPn, ParseNode* afterPn) if ( inDeadCode ( ) )  inline bool inDeadCode() const return curBlock_ == nullptr ; MBasicBlock * body ; if ( ! newBlock ( curBlock_ , & body , bodyPn ) )  bool newBlock(MBasicBlock* pred, MBasicBlock** block, ParseNode* pn) return newBlockWithDepth ( pred , loopStack_ . length ( ) , block , pn ) ; bool newBlockWithDepth(MBasicBlock* pred, unsigned loopDepth, MBasicBlock** block, ParseNode* pn) * block = MBasicBlock :: NewAsmJS ( mirGraph ( ) , info ( ) , pred , MBasicBlock :: NORMAL ); CompileInfo &  info() const return * info_ ; MIRGraph &     mirGraph() const return * graph_ ; if ( ! * block )  return false ; return true ; if ( cond -> isConstant ( ) && cond -> toConstant ( ) -> valueToBoolean ( ) )  if ( ! newBlockWithDepth ( curBlock_ , curBlock_ -> loopDepth ( ) - 1 , afterLoop , afterPn ) )  bool newBlockWithDepth(MBasicBlock* pred, unsigned loopDepth, MBasicBlock** block, ParseNode* pn) * block = MBasicBlock :: NewAsmJS ( mirGraph ( ) , info ( ) , pred , MBasicBlock :: NORMAL ); if ( ! * block )  return false ; return true ; curBlock_ -> end ( MTest :: New ( alloc ( ) , cond , body , * afterLoop ) ); return * alloc_ ; TempAllocator &     alloc() const 