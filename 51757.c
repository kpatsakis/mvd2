static void rtl8139_transmit(RTL8139State *s) int descriptor = s -> currTxDesc , txcount = 0 ; if ( rtl8139_transmit_one ( s , descriptor ) )  static int rtl8139_transmit_one(RTL8139State *s, int descriptor) if ( ! rtl8139_transmitter_enabled ( s ) )  static int rtl8139_transmitter_enabled(RTL8139State *s) return s -> bChipCmdState & CmdTxEnb ; if ( s -> TxStatus [ descriptor ] & TxHostOwns )  int txsize = s -> TxStatus [ descriptor ] & 0x1fff ; uint8_t txbuffer [ 0x2000 ] ; s -> TxStatus [ descriptor ] |= TxHostOwns; s -> TxStatus [ descriptor ] |= TxStatOK; rtl8139_transfer_frame ( s , txbuffer , txsize , 0 , NULL ); static void rtl8139_transfer_frame(RTL8139State *s, uint8_t *buf, int int do_interrupt, const uint8_t *dot1q_buf) struct iovec * iov = NULL ; struct iovec vlan_iov [ 3 ] ; if ( ! size )  if ( dot1q_buf && size >= ETHER_ADDR_LEN * 2 )  iov = ( struct iovec [ 3 ] . iov_base = buf , . iov_len = ETHER_ADDR_LEN * 2 . iov_base = ( void * ) dot1q_buf , . iov_len = VLAN_HLEN . iov_base = buf + ETHER_ADDR_LEN * 2 . iov_len = size - ETHER_ADDR_LEN * 2 , memcpy ( vlan_iov , iov , sizeof ( vlan_iov ) ); iov = vlan_iov; if ( TxLoopBack == ( s -> TxConfig & TxLoopBack ) )  size_t buf2_size ; uint8_t * buf2 ; if ( iov )  buf2_size = iov_size ( iov , 3 ); buf2 = g_malloc ( buf2_size ); buf = buf2; rtl8139_do_receive ( qemu_get_queue ( s -> nic ) , buf , size , do_interrupt ); static ssize_t rtl8139_do_receive(NetClientState *nc, const uint8_t *buf, size_t size_, int do_interrupt) RTL8139State * s = qemu_get_nic_opaque ( nc ) ; static const uint8_t broadcast_macaddr [ 6 ] = { 0xff , 0xff , 0xff , 0xff , 0xff , 0xff } ; if ( ! s -> clock_enabled )  if ( ! rtl8139_receiver_enabled ( s ) )  if ( s -> RxConfig & AcceptAllPhys )  if ( ! memcmp ( buf , broadcast_macaddr , 6 ) )  