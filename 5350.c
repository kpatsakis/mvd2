static ne_read_discard_padding(nestegg * ctx, nestegg_packet * pkt) int r ; uint64_t id , size ; struct ebml_element_desc * element ; r = ne_peek_element ( ctx , & id , & size ); static ne_peek_element(nestegg * ctx, uint64_t * id, uint64_t * size) int r ; if ( ctx -> last_valid )  return 1 ; r = ne_read_id ( ctx -> io , & ctx -> last_id , NULL ); if ( r != 1 )  return r ; r = ne_read_vint ( ctx -> io , & ctx -> last_size , NULL ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  if ( id != ID_DISCARD_PADDING )  element = ne_find_element ( id , ctx -> ancestor -> node ); static struct ebml_element_desc ne_find_element(uint64_t id, struct ebml_element_desc * elements) struct ebml_element_desc * element ; for (element = elements; element->id; ++element) if ( element -> id == id )  return element ; return NULL ; if ( ! element )  r = ne_read_simple ( ctx , element , size ); static ne_read_simple(nestegg * ctx, struct ebml_element_desc * desc, size_t length) struct ebml_type * storage ; int r ; storage = ( struct ebml_type * ) ( ctx -> ancestor -> data + desc -> offset ); if ( storage -> read )  storage -> type = desc -> type; switch ( desc -> type )  r = ne_read_string ( ctx , & storage -> v . s , length ); static ne_read_string(nestegg * ctx, char ** val, uint64_t length) char * str ; if ( length > LIMIT_STRING )  str = ne_pool_alloc ( length + 1 , ctx -> alloc_pool ); static void ne_pool_alloc(size_t size, struct pool_ctx * pool) void * p ; p = h_malloc ( size ); if ( ! p )  memset ( p , 0 , size ); return p ; 