 nestegg_read_packet(nestegg * ctx, nestegg_packet ** pkt) uint64_t id , size ; r = ne_peek_element ( ctx , & id , & size ); static ne_peek_element(nestegg * ctx, uint64_t * id, uint64_t * size) int r ; if ( ctx -> last_valid )  return 1 ; r = ne_read_id ( ctx -> io , & ctx -> last_id , NULL ); if ( r != 1 )  return r ; r = ne_read_vint ( ctx -> io , & ctx -> last_size , NULL ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  if ( ne_is_suspend_element ( id ) )  static ne_is_suspend_element(uint64_t id) if ( id == ID_SIMPLE_BLOCK || id == ID_BLOCK )  return 1 ; return 0 ; r = ne_parse ( ctx , NULL , - 1 ); if ( r != 1 )  static ne_parse(nestegg * ctx, struct ebml_element_desc * top_level, int64_t max_offset) int r ; int64_t * data_offset ; uint64_t id , size , peeked_id ; struct ebml_element_desc * element ; if ( ! ctx -> ancestor )  if ( max_offset > 0 && ne_io_tell ( ctx -> io ) >= max_offset )  r = ne_peek_element ( ctx , & id , & size ); if ( r != 1 )  element = ne_find_element ( id , ctx -> ancestor -> node ); if ( element )  if ( element -> flags & DESC_FLAG_SUSPEND )  r = ne_read_element ( ctx , & id , & size ); if ( r != 1 )  if ( element -> flags & DESC_FLAG_OFFSET )  data_offset = ( int64_t * ) ( ctx -> ancestor -> data + element -> data_offset ); * data_offset = ne_io_tell ( ctx -> io ); if ( * data_offset < 0 )  if ( element -> type == TYPE_MASTER )  if ( element -> flags & DESC_FLAG_MULTI )  if ( ne_read_master ( ctx , element ) < 0 )  if ( ne_read_single_master ( ctx , element ) < 0 )  r = ne_read_simple ( ctx , element , size ); if ( r < 0 )  if ( ne_is_ancestor_element ( id , ctx -> ancestor -> previous ) )  if ( top_level && ctx -> ancestor -> node == top_level )  r = ne_read_element ( ctx , & id , & size ); if ( r != 1 )  r = ne_io_read_skip ( ctx -> io , size ); if ( r != 1 )  static ne_read_master(nestegg * ctx, struct ebml_element_desc * desc) struct ebml_list_node * node , * oldtail ; node = ne_pool_alloc ( sizeof ( * node ) , ctx -> alloc_pool ); if ( ! node )  node -> id = desc -> id; node -> data = ne_pool_alloc ( desc -> size , ctx -> alloc_pool ); static void ne_pool_alloc(size_t size, struct pool_ctx * pool) void * p ; p = h_malloc ( size ); if ( ! p )  memset ( p , 0 , size ); return p ; 