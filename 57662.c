static int xc2028_set_params(struct dvb_frontend *fe) struct dtv_frontend_properties * c = & fe -> dtv_property_cache ; u32 delsys = c -> delivery_system ; u32 bw = c -> bandwidth_hz ; struct xc2028_data * priv = fe -> tuner_priv ; int rc ; unsigned int type = 0 ; u16 demod = 0 ; rc = check_device_status ( priv ); static int check_device_status(struct xc2028_data *priv) switch ( priv -> state )  return - EAGAIN ; return 1 ; return 0 ; return - ENODEV ; return 0 ; if ( rc < 0 )  switch ( delsys )  if ( bw <= 6000000 )  type |= QAM; switch ( priv -> ctrl . type )  type |= D2633; type |= D2620; if ( priv -> ctrl . demod == XC3028_FE_ZARLINK456 )  type |= D2633; type |= D2620; type |= ATSC | D2633; if ( bw <= 6000000 )  type |= DTV6; priv -> ctrl . vhfbw7 = 0; priv -> ctrl . uhfbw8 = 0; if ( bw <= 7000000 )  if ( c -> frequency < 470000000 )  priv -> ctrl . vhfbw7 = 1; priv -> ctrl . uhfbw8 = 0; type |= ( priv -> ctrl . vhfbw7 && priv -> ctrl . uhfbw8 ) ? DTV78 : DTV7; type |= F8MHZ; if ( c -> frequency < 470000000 )  priv -> ctrl . vhfbw7 = 0; priv -> ctrl . uhfbw8 = 1; type |= ( priv -> ctrl . vhfbw7 && priv -> ctrl . uhfbw8 ) ? DTV78 : DTV8; type |= F8MHZ; if ( priv -> ctrl . demod )  demod = priv -> ctrl . demod; if ( type == ATSC || priv -> firm_version < 0x0302 )  demod += 200; return generic_set_freq ( fe , c -> frequency , V4L2_TUNER_DIGITAL_TV , type , 0 , demod ) ; static int generic_set_freq(struct dvb_frontend *fe, u32 freq /* in HZ enum v4l2_tuner_type unsigned int v4l2_std_id u16 int_freq) if ( check_firmware ( fe , type , std , int_freq ) < 0 )  static int check_firmware(struct dvb_frontend *fe, unsigned int v4l2_std_id std, __u16 int_freq) struct xc2028_data * priv = fe -> tuner_priv ; struct firmware_properties new_fw ; int rc , retry_count = 0 ; u16 version , hwmodel ; v4l2_std_id std0 ; rc = check_device_status ( priv ); static int check_device_status(struct xc2028_data *priv) switch ( priv -> state )  return - EAGAIN ; return 1 ; return 0 ; return - ENODEV ; return 0 ; if ( rc < 0 )  if ( priv -> ctrl . mts && ! ( type & FM ) )  type |= MTS; new_fw . type = type; new_fw . id = std; new_fw . std_req = std; new_fw . scode_table = SCODE | priv -> ctrl . scode_table; new_fw . scode_nr = 0; new_fw . int_freq = int_freq; if ( ( priv -> state == XC2028_ACTIVE ) && ( ( ( BASE | new_fw . type ) & BASE_TYPES ) == ( priv -> cur_fw . type & BASE_TYPES ) ) )  memset ( & priv -> cur_fw , 0 , sizeof ( priv -> cur_fw ) ); rc = do_tuner_callback ( fe , XC2028_TUNER_RESET , 0 ); static inline int do_tuner_callback(struct dvb_frontend *fe, int cmd, int arg) struct xc2028_data * priv = fe -> tuner_priv ; return ( ! fe -> callback ) ? - EINVAL : fe -> callback ( ( ( fe -> dvb ) && ( fe -> dvb -> priv ) ) ? fe -> dvb -> priv : priv -> i2c_props . adap -> algo_data , DVB_FRONTEND_COMPONENT_TUNER , cmd , arg ) ; if ( rc < 0 )  std0 = 0; rc = load_firmware ( fe , BASE | new_fw . type , & std0 ); if ( rc < 0 )  rc = load_firmware ( fe , BASE | INIT1 | new_fw . type , & std0 ); if ( rc == - ENOENT )  rc = load_firmware ( fe , ( BASE | INIT1 | new_fw . type ) & ~F8MHZ , & std0 ); if ( rc < 0 && rc != - ENOENT )  if ( priv -> cur_fw . type == ( BASE | new_fw . type ) && priv -> cur_fw . std_req == std )  priv -> cur_fw . scode_table = 0; rc = load_firmware ( fe , new_fw . type , & new_fw . id ); if ( rc == - ENOENT )  rc = load_firmware ( fe , new_fw . type & ~F8MHZ , & new_fw . id ); if ( rc < 0 )  if ( xc2028_get_reg ( priv , 0x0004 , & version ) < 0 || xc2028_get_reg ( priv , 0x0008 , & hwmodel ) < 0 )  static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val) unsigned char buf [ 2 ] ; unsigned char ibuf [ 2 ] ; buf [ 0 ] = reg >> 8; buf [ 1 ] = ( unsigned char ) reg; if ( i2c_send_recv ( priv , buf , 2 , ibuf , 2 ) != 2 )  return - EIO ; return 0 ; static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val) unsigned char buf [ 2 ] ; unsigned char ibuf [ 2 ] ; buf [ 0 ] = reg >> 8; buf [ 1 ] = ( unsigned char ) reg; if ( i2c_send_recv ( priv , buf , 2 , ibuf , 2 ) != 2 )  return - EIO ; return 0 ; if ( priv -> ctrl . read_not_reliable )  if ( priv -> firm_version != ( ( version & 0xf0 ) << 4 | ( version & 0x0f ) ) )  if ( ! priv -> ctrl . read_not_reliable )  hwmodel = 3028; if ( priv -> hwmodel == 0 && ( hwmodel == 2028 || hwmodel == 3028 ) )  priv -> hwmodel = hwmodel; priv -> hwvers = version & 0xff00; if ( priv -> hwmodel == 0 || priv -> hwmodel != hwmodel || priv -> hwvers != ( version & 0xff00 ) )  priv -> cur_fw = new_fw; priv -> cur_fw . type |= BASE; priv -> state = XC2028_ACTIVE; priv -> state = XC2028_NO_FIRMWARE; if ( retry_count < 8 )  retry_count ++; static int load_firmware(struct dvb_frontend *fe, unsigned int v4l2_std_id *id) struct xc2028_data * priv = fe -> tuner_priv ; int pos , rc ; unsigned char * p , * endp , buf [ MAX_XFER_SIZE ] ; if ( priv -> ctrl . max_len > sizeof ( buf ) )  priv -> ctrl . max_len = sizeof ( buf ); pos = seek_firmware ( fe , type , id ); static int seek_firmware(struct dvb_frontend *fe, unsigned int v4l2_std_id *id) struct xc2028_data * priv = fe -> tuner_priv ; int i , best_i = - 1 , best_nr_matches = 0 ; unsigned int type_mask = 0 ; if ( ! priv -> firm )  return - EINVAL ; if ( ( ( type & ~SCODE ) == 0 ) && ( * id == 0 ) )  * id = V4L2_STD_PAL; if ( type & BASE )  type_mask = BASE_TYPES; if ( type & SCODE )  type &= SCODE_TYPES; type_mask = SCODE_TYPES & ~HAS_IF; if ( type & DTV_TYPES )  type_mask = DTV_TYPES; if ( type & STD_SPECIFIC_TYPES )  type_mask = STD_SPECIFIC_TYPES; type &= type_mask; if ( ! ( type & SCODE ) )  type_mask = ~0; for (i = 0; i < priv->firm_size; i++) if ( ( type == ( priv -> firm [ i ] . type & type_mask ) ) && ( * id == priv -> firm [ i ] . id ) )  for (i = 0; i < priv->firm_size; i++) v4l2_std_id match_mask ; int nr_matches ; if ( type != ( priv -> firm [ i ] . type & type_mask ) )  match_mask = * id & priv -> firm [ i ] . id; if ( ! match_mask )  if ( ( * id & match_mask ) == * id )  nr_matches = hweight64 ( match_mask ); if ( nr_matches > best_nr_matches )  best_nr_matches = nr_matches; best_i = i; if ( best_nr_matches > 0 )  i = best_i; i = - ENOENT; return i ; if ( pos < 0 )  p = priv -> firm [ pos ] . ptr; endp = p + priv -> firm [ pos ] . size; while ( p < endp )  __u16 size ; if ( p + sizeof ( size ) > endp )  size = le16_to_cpu ( * ( __le16 * ) p ); p += sizeof ( size ); if ( size == 0xffff )  if ( ! size )  rc = do_tuner_callback ( fe , XC2028_TUNER_RESET , 0 ); static inline int do_tuner_callback(struct dvb_frontend *fe, int cmd, int arg) struct xc2028_data * priv = fe -> tuner_priv ; return ( ! fe -> callback ) ? - EINVAL : fe -> callback ( ( ( fe -> dvb ) && ( fe -> dvb -> priv ) ) ? fe -> dvb -> priv : priv -> i2c_props . adap -> algo_data , DVB_FRONTEND_COMPONENT_TUNER , cmd , arg ) ; if ( rc < 0 )  if ( size >= 0xff00 )  switch ( size )  rc = do_tuner_callback ( fe , XC2028_RESET_CLK , 0 ); static inline int do_tuner_callback(struct dvb_frontend *fe, int cmd, int arg) struct xc2028_data * priv = fe -> tuner_priv ; return ( ! fe -> callback ) ? - EINVAL : fe -> callback ( ( ( fe -> dvb ) && ( fe -> dvb -> priv ) ) ? fe -> dvb -> priv : priv -> i2c_props . adap -> algo_data , DVB_FRONTEND_COMPONENT_TUNER , cmd , arg ) ; if ( rc < 0 )  if ( size & 0x8000 )  if ( size + p > endp )  buf [ 0 ] = * p; p ++; size --; while ( size > 0 )  int len = ( size < priv -> ctrl . max_len - 1 ) ? size : priv -> ctrl . max_len - 1 ; memcpy ( buf + 1 , p , len ); rc = i2c_send ( priv , buf , len + 1 ); if ( rc < 0 )  tuner_err ( "%d returned from send\n" , rc ); p += len; size -= len; rc = do_tuner_callback ( fe , XC2028_I2C_FLUSH , 0 ); static inline int do_tuner_callback(struct dvb_frontend *fe, int cmd, int arg) struct xc2028_data * priv = fe -> tuner_priv ; return ( ! fe -> callback ) ? - EINVAL : fe -> callback ( ( ( fe -> dvb ) && ( fe -> dvb -> priv ) ) ? fe -> dvb -> priv : priv -> i2c_props . adap -> algo_data , DVB_FRONTEND_COMPONENT_TUNER , cmd , arg ) ; if ( ( rc < 0 ) && ( rc != - EINVAL ) )  tuner_err ( "error executing flush: %d\n" , rc ); return rc ; 