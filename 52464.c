static int CVE_2013_6380_VULN_aac_send_raw_srb(struct aac_dev* dev, void __user * arg) struct fib * srbfib ; struct user_aac_srb __user * user_srb = arg ; u32 fibsize = 0 ; u32 data_dir ; void * sg_list [ 32 ] ; if ( dev -> in_reset )  if ( ! capable ( CAP_SYS_ADMIN ) )  if ( ! ( srbfib = aac_fib_alloc ( dev ) ) )  memset ( sg_list , 0 , sizeof ( sg_list ) ); if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) )  if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) )  user_srbcmd = kmalloc ( fibsize , GFP_KERNEL ); if ( ! user_srbcmd )  if ( copy_from_user ( user_srbcmd , user_srb , fibsize ) )  flags = user_srbcmd -> flags; switch ( flags & ( SRB_DataIn | SRB_DataOut ) )  data_dir = DMA_TO_DEVICE; data_dir = DMA_BIDIRECTIONAL; data_dir = DMA_FROM_DEVICE; data_dir = DMA_NONE; if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) )  actual_fibsize = sizeof ( struct aac_srb ) - sizeof ( struct sgentry ) + ( ( user_srbcmd -> sg . count & 0xff ) * sizeof ( struct sgentry ) ); actual_fibsize64 = actual_fibsize + ( user_srbcmd -> sg . count & 0xff ) * ( sizeof ( struct sgentry64 ) - sizeof ( struct sgentry ) ); if ( ( actual_fibsize != fibsize ) && ( actual_fibsize64 != fibsize ) )  if ( ( data_dir == DMA_NONE ) && user_srbcmd -> sg . count )  if ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 )  struct user_sgmap64 * upsg = ( struct user_sgmap64 * ) & user_srbcmd -> sg ; if ( actual_fibsize64 == fibsize )  struct user_sgmap * usg ; usg = kmalloc ( actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) , GFP_KERNEL ); if ( ! usg )  memcpy ( usg , upsg , actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) ); for (i = 0; i < usg->count; i++) if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) )  kfree ( usg ); p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ); if ( ! p )  dprintk ( ( KERN_DEBUG "aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n" usg -> sg [ i ] . count , i , usg -> count ) ) kfree ( usg ); sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr; sg_list [ i ] = p; sg_indx = i; if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) )  kfree ( usg ); addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ); psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ); psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ); byte_count += usg -> sg [ i ] . count; psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ); kfree ( usg ); srbcmd -> count = cpu_to_le32 ( byte_count ); psg -> count = cpu_to_le32 ( sg_indx + 1 ); dprintk ( ( KERN_DEBUG "aacraid: Could not send raw srb fib to hba\n" ) ) for(i = 0 ; i <= sg_indx; i++) byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ); if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) )  dprintk ( ( KERN_DEBUG "aacraid: Could not copy sg data to user\n" ) ) dprintk ( ( KERN_DEBUG "aacraid: Could not copy reply to user\n" ) ) for(i=0; i <= sg_indx; i++) kfree ( sg_list [ i ] ); 