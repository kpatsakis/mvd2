int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle int AVPacket *avpkt) if ( ! avpkt -> data && avpkt -> size )  if ( ! avctx -> codec )  if ( avctx -> codec -> type != AVMEDIA_TYPE_SUBTITLE )  if ( ( avctx -> codec -> capabilities & AV_CODEC_CAP_DELAY ) || avpkt -> size )  AVPacket pkt_recoded ; AVPacket tmp = * avpkt ; int did_split = av_packet_split_side_data ( & tmp ) ; if ( did_split )  memset ( tmp . data + tmp . size , 0 , FFMIN ( avpkt -> size - tmp . size , AV_INPUT_BUFFER_PADDING_SIZE ) ); pkt_recoded = tmp; ret = recode_subtitle ( avctx , & pkt_recoded , & tmp ); static int recode_subtitle(AVCodecContext AVPacket *outpkt, const AVPacket *inpkt) char * inb , * outb ; size_t inl , outl ; AVPacket tmp ; if ( avctx -> sub_charenc_mode != FF_SUB_CHARENC_MODE_PRE_DECODER || inpkt -> size == 0 )  return 0 ; cd = iconv_open ( "UTF-8" , avctx -> sub_charenc ); inb = inpkt -> data; inl = inpkt -> size; if ( inl >= INT_MAX / UTF8_MAX_BYTES - AV_INPUT_BUFFER_PADDING_SIZE )  ret = AVERROR ( ENOMEM ); ret = av_new_packet ( & tmp , inl * UTF8_MAX_BYTES ); if ( ret < 0 )  outpkt -> buf = tmp . buf; outpkt -> data = tmp . data; outpkt -> size = tmp . size; outb = outpkt -> data; outl = outpkt -> size; if ( iconv ( cd , & inb , & inl , & outb , & outl ) == ( size_t ) - 1 || iconv ( cd , NULL , NULL , & outb , & outl ) == ( size_t ) - 1 || outl >= outpkt -> size || inl != 0 )  ret = FFMIN ( AVERROR ( errno ) , - 1 ); return ret ; if ( ret < 0 )  avctx -> internal -> pkt = & pkt_recoded; if ( avctx -> pkt_timebase . den && avpkt -> pts != AV_NOPTS_VALUE )  sub -> pts = av_rescale_q ( avpkt -> pts , avctx -> pkt_timebase , AV_TIME_BASE_Q ); if ( sub -> num_rects && ! sub -> end_display_time && avpkt -> duration && avctx -> pkt_timebase . num )  AVRational ms = { 1 , 1000 } ; sub -> end_display_time = av_rescale_q ( avpkt -> duration , avctx -> pkt_timebase , ms ); for (i = 0; i < sub->num_rects; i++) if ( sub -> rects [ i ] -> ass && ! utf8_check ( sub -> rects [ i ] -> ass ) )  static int utf8_check(const uint8_t *str) const uint8_t * byte ; uint32_t codepoint , min ; while ( * str )  byte = str; min = byte - str == 1 ? 0 : byte - str == 2 ? 0x80 : 1 << ( 5 * ( byte - str ) - 4 ); if ( codepoint < min || codepoint >= 0x110000 || codepoint == 0xFFFE || codepoint >= 0xD800 && codepoint <= 0xDFFF )  return 0 ; str = byte; return 1 ; avsubtitle_free ( sub ); void avsubtitle_free(AVSubtitle *sub) memset ( sub , 0 , sizeof ( AVSubtitle ) ); 