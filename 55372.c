static int CVE_2010_4165_VULN_do_tcp_setsockopt(struct sock *sk, int int optname, char __user *optval, unsigned int optlen) struct tcp_sock * tp = tcp_sk ( sk ) ; switch ( optname )  struct tcp_cookie_transactions ctd ; struct tcp_cookie_values * cvp = NULL ; if ( sizeof ( ctd ) > optlen )  if ( copy_from_user ( & ctd , optval , sizeof ( ctd ) ) )  if ( ctd . tcpct_used > sizeof ( ctd . tcpct_value ) || ctd . tcpct_s_data_desired > TCP_MSS_DESIRED )  if ( ctd . tcpct_cookie_desired == 0 )  if ( ( 0x1 & ctd . tcpct_cookie_desired ) || ctd . tcpct_cookie_desired > TCP_COOKIE_MAX || ctd . tcpct_cookie_desired < TCP_COOKIE_MIN )  if ( TCP_COOKIE_OUT_NEVER & ctd . tcpct_flags )  if ( ctd . tcpct_used > 0 || ( tp -> cookie_values == NULL && ( sysctl_tcp_cookie_size > 0 || ctd . tcpct_cookie_desired > 0 || ctd . tcpct_s_data_desired > 0 ) ) )  cvp = kzalloc ( sizeof ( * cvp ) + ctd . tcpct_used , GFP_KERNEL ); if ( cvp == NULL )  tp -> rx_opt . cookie_in_always = ( TCP_COOKIE_IN_ALWAYS & ctd . tcpct_flags ); tp -> rx_opt . cookie_out_never = 0; if ( tp -> cookie_values != NULL )  if ( cvp != NULL )  cvp = tp -> cookie_values; if ( cvp != NULL )  cvp -> cookie_desired = ctd . tcpct_cookie_desired; if ( ctd . tcpct_used > 0 )  memcpy ( cvp -> s_data_payload , ctd . tcpct_value , ctd . tcpct_used ); cvp -> s_data_desired = ctd . tcpct_used; cvp -> s_data_constant = 1; 