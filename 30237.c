static void e100_nic_realize(PCIDevice *pci_dev, Error **errp) EEPRO100State * s = DO_UPCAST ( EEPRO100State , dev , pci_dev ) ; E100PCIDeviceInfo * info = eepro100_get_class ( s ) ; static E100PCIDeviceInfo *eepro100_get_class(EEPRO100State *s) return eepro100_get_class_by_name ( object_get_typename ( OBJECT ( s ) ) ) ; static E100PCIDeviceInfo *eepro100_get_class_by_name(const char *typename) E100PCIDeviceInfo * info = NULL ; int i ; for (i = 0; i < ARRAY_SIZE(e100_devices); i++) if ( strcmp ( e100_devices [ i ] . name , typename ) == 0 )  info = & e100_devices [ i ]; return info ; s -> device = info -> device; e100_pci_reset ( s ); static void e100_pci_reset(EEPRO100State * s) E100PCIDeviceInfo * info = eepro100_get_class ( s ) ; static E100PCIDeviceInfo *eepro100_get_class(EEPRO100State *s) return eepro100_get_class_by_name ( object_get_typename ( OBJECT ( s ) ) ) ; s -> stats_size = info -> stats_size; s -> has_extended_tcb_support = info -> has_extended_tcb_support; s -> configuration [ 6 ] |= BIT ( 4 ); s -> configuration [ 6 ] |= BIT ( 5 ); if ( s -> stats_size == 80 )  if ( s -> configuration [ 6 ] & BIT ( 5 ) )  s -> stats_size = 64; if ( info -> power_management )  int cfg_offset = 0xdc ; int r = pci_add_capability ( & s -> dev , PCI_CAP_ID_PM , cfg_offset , PCI_PM_SIZEOF ) ; assert ( r >= 0 ); 