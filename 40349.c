static sg_new_write(Sg_fd *sfp, struct file *file, const char __user size_t count, int blocking, int read_only, int Sg_request **o_srp) int k ; Sg_request * srp ; sg_io_hdr_t * hp ; unsigned char cmnd [ SG_MAX_CDB_SIZE ] ; int timeout ; unsigned long ul_timeout ; if ( count < SZ_SG_IO_HDR )  if ( ! access_ok ( VERIFY_READ , buf , count ) )  sfp -> cmd_q = 1; if ( ! ( srp = sg_add_request ( sfp ) ) )  srp -> sg_io_owned = sg_io_owned; hp = & srp -> header; if ( __copy_from_user ( hp , buf , SZ_SG_IO_HDR ) )  if ( hp -> interface_id != 'S' )  if ( hp -> flags & SG_FLAG_MMAP_IO )  if ( hp -> dxfer_len > sfp -> reserve . bufflen )  if ( hp -> flags & SG_FLAG_DIRECT_IO )  if ( sg_res_in_use ( sfp ) )  ul_timeout = msecs_to_jiffies ( srp -> header . timeout ); timeout = ( ul_timeout < INT_MAX ) ? ul_timeout : INT_MAX; if ( ( ! hp -> cmdp ) || ( hp -> cmd_len < 6 ) || ( hp -> cmd_len > sizeof ( cmnd ) ) )  if ( ! access_ok ( VERIFY_READ , hp -> cmdp , hp -> cmd_len ) )  if ( __copy_from_user ( cmnd , hp -> cmdp , hp -> cmd_len ) )  if ( read_only && sg_allow_access ( file , cmnd ) )  k = sg_common_write ( sfp , srp , cmnd , timeout , blocking ); static sg_common_write(Sg_fd * sfp, Sg_request * unsigned char *cmnd, int timeout, int blocking) int k , at_head ; srp -> data . cmd_opcode = cmnd [ 0 ]; k = sg_start_req ( srp , cmnd ); if ( k )  sg_finish_rem_req ( srp ); static sg_finish_rem_req(Sg_request *srp) Sg_fd * sfp = srp -> parentfp ; Sg_scatter_hold * req_schp = & srp -> data ; if ( srp -> res_used )  sg_remove_scat ( sfp , req_schp ); static sg_remove_scat(Sg_fd * sfp, Sg_scatter_hold * schp) memset ( schp , 0 , sizeof ( * schp ) ); 