proto_item proto_tree_add_bitmask_text(proto_tree *parent_tree, tvbuff_t const guint offset, const guint const char *name, const char const gint ett, const int const guint encoding, const int flags) if ( parent_tree )  item = proto_tree_add_text_internal ( parent_tree , tvb , offset , len , "%s" , name ? name : "" ); if ( proto_item_add_bitmask_tree ( item , tvb , offset , len , ett , fields , encoding , flags , TRUE , FALSE , FALSE , NULL , 0 ) && fallback )  static proto_item_add_bitmask_tree(proto_item *item, tvbuff_t *tvb, const int const int len, const gint ett, const int const guint encoding, const int gboolean first, gboolean use_parent_tree, gboolean proto_tree* tree, guint64 value) guint64 available_bits = 0 ; guint64 tmpval ; header_field_info * hf ; switch ( len )  if ( use_value == FALSE )  value = tvb_get_guint8 ( tvb , offset ); available_bits = 0xFF; if ( use_value == FALSE )  value = encoding ? tvb_get_letohs ( tvb , offset ) : tvb_get_ntohs ( tvb , offset ); available_bits = 0xFFFF; if ( use_value == FALSE )  value = encoding ? tvb_get_letoh24 ( tvb , offset ) : tvb_get_ntoh24 ( tvb , offset ); available_bits = 0xFFFFFF; if ( use_value == FALSE )  value = encoding ? tvb_get_letohl ( tvb , offset ) : tvb_get_ntohl ( tvb , offset ); available_bits = 0xFFFFFFFF; if ( use_value == FALSE )  value = encoding ? tvb_get_letoh40 ( tvb , offset ) : tvb_get_ntoh40 ( tvb , offset ); available_bits = G_GUINT64_CONSTANT ( 0xFFFFFFFFFF ); if ( use_value == FALSE )  value = encoding ? tvb_get_letoh48 ( tvb , offset ) : tvb_get_ntoh48 ( tvb , offset ); available_bits = G_GUINT64_CONSTANT ( 0xFFFFFFFFFFFF ); if ( use_value == FALSE )  value = encoding ? tvb_get_letoh56 ( tvb , offset ) : tvb_get_ntoh56 ( tvb , offset ); available_bits = G_GUINT64_CONSTANT ( 0xFFFFFFFFFFFFFF ); if ( use_value == FALSE )  value = encoding ? tvb_get_letoh64 ( tvb , offset ) : tvb_get_ntoh64 ( tvb , offset ); available_bits = G_GUINT64_CONSTANT ( 0xFFFFFFFFFFFFFFFF ); while ( * fields )  guint64 present_bits ; present_bits = available_bits & hf -> bitmask; if ( present_bits != hf -> bitmask )  fields ++; if ( flags & BMT_NO_APPEND )  fields ++; tmpval = ( value & hf -> bitmask ) >> hfinfo_bitshift ( hf ); switch ( hf -> type )  if ( hf -> display == BASE_CUSTOM )  if ( hf -> strings )  if ( ! ( flags & BMT_NO_INT ) )  char buf [ 32 ] ; const char * out ; out = hfinfo_number_value_format ( hf , buf , ( guint32 ) tmpval ); static const char hfinfo_number_value_format(const header_field_info *hfinfo, char buf[32], guint32 value) int display = hfinfo -> display ; if ( hfinfo -> type == FT_FRAMENUM )  display = BASE_DEC; return hfinfo_number_value_format_display ( hfinfo , display , buf , value ) ; static const char hfinfo_number_value_format_display(const header_field_info *hfinfo, int display, char buf[32], guint32 value) char * ptr = & buf [ 31 ] ; gboolean isint = IS_FT_INT ( hfinfo -> type ) ; * ptr = '\0'; switch ( display & FIELD_DISPLAY_E_MASK )  return isint ? int_to_str_back ( ptr , ( gint32 ) value ) : uint_to_str_back ( ptr , value ) ; * ( -- ptr ) = ')'; ptr = hex_to_str_back ( ptr , _hfinfo_type_hex_octet ( hfinfo -> type ) , value ); static _hfinfo_type_hex_octet(int type) switch ( type )  return 2 ; return 4 ; return 6 ; return 8 ; return 10 ; return 12 ; return 14 ; return 16 ; return - 1 ; * ( -- ptr ) = '('; * ( -- ptr ) = ' '; ptr = isint ? int_to_str_back ( ptr , ( gint32 ) value ) : uint_to_str_back ( ptr , value ); return ptr ; return oct_to_str_back ( ptr , value ) ; return hex_to_str_back ( ptr , _hfinfo_type_hex_octet ( hfinfo -> type ) , value ) ; static _hfinfo_type_hex_octet(int type) switch ( type )  return 2 ; return 4 ; return 6 ; return 8 ; return 10 ; return 12 ; return 14 ; return 16 ; return - 1 ; * ( -- ptr ) = ')'; ptr = isint ? int_to_str_back ( ptr , ( gint32 ) value ) : uint_to_str_back ( ptr , value ); * ( -- ptr ) = '('; * ( -- ptr ) = ' '; ptr = hex_to_str_back ( ptr , _hfinfo_type_hex_octet ( hfinfo -> type ) , value ); static _hfinfo_type_hex_octet(int type) switch ( type )  return 2 ; return 4 ; return 6 ; return 8 ; return 10 ; return 12 ; return 14 ; return 16 ; return - 1 ; return ptr ; return buf ; return ptr ; proto_item_append_text ( item , "%s: %s" , hf -> name , out ); fields ++;  proto_item_append_text(proto_item *pi, const char *format, ...) size_t curlen ; fi = PITEM_FINFO ( pi ); if ( fi == NULL )  if ( ! PROTO_ITEM_IS_HIDDEN ( pi ) )  curlen = strlen ( fi -> rep -> representation ); if ( ITEM_LABEL_LENGTH > curlen )  g_vsnprintf ( fi -> rep -> representation + curlen , ITEM_LABEL_LENGTH - ( gulong ) curlen , format , ap ); 